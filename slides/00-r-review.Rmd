---
title: "00 R, Rmarkdown, code, and {tidyverse}: <br> A whirlwind tour"
author: 
  - "STAT 406"
  - "Daniel J. McDonald"
date: 'Last modified - `r Sys.Date()`'
---

```{r setup, include=FALSE}
source("rmd_config.R")
```

class: middle, inverse, center

# The basics

---
## Tour of Rstudio

Things to note

1. Console
2. Terminal
3. Scripts, .Rmd, Knit
4. Files, Projects
5. Getting help
6. Environment, Git

---
## Simple stuff

.pull-left[
### Vectors:
```{r}
x <- c(1, 3, 4)
x[1]
x[-1]
rev(x)
c(x, x)
```
]

.pull-right[
### Matrices:
```{r}
x <- matrix(1:25, nrow = 5, ncol = 5)
x[1,]
x[,-1]
x[c(1,3),  2:3]
```

]

---
## Simple stuff

.pull-left[
### Lists
```{r}
(l <- list(a = letters[1:2], b = 1:4, c = list(a = 1)))
l$a
l$c$a
l["b"]
```
]

.pull-right[
### Data frames
```{r}
(dat <- data.frame(z = 1:5, b = 6:10, c = letters[1:5]))
class(dat)
dat$b
dat[1,]
```

.secondary[Data frames are sort-of lists and sort-of matrices]
]

---

## Tibbles

.secondary[These are `{tidyverse}` data frames]

```{r}
(dat2 <- tibble(z = 1:5, b = z + 5, c = letters[z]))
class(dat2)
```

We'll return to classes in a moment. A `tbl_df` is a "subclass" of `data.frame`.

Anything that `data.frame` can do, `tbl_df` can do (better).

For instance, the printing is more informative.

Also, you can construct one by referencing previously constructed columns.
---
class: middle, inverse, center

# Functions

---

## Understanding signatures

```{r echo=FALSE}
sig <- sig::sig
```

```{r}
sig(lm)
sig(`+`)
sig(ggplot2::layer)
sig(epipredict::layer)
sig(rnorm)
```

---

## These are all the same

```{r}
set.seed(12345)
rnorm(3)
set.seed(12345)
rnorm(n = 3, mean = 0)
set.seed(12345)
rnorm(3, 0, 1)
set.seed(12345)
rnorm(sd = 1, n = 3, mean = 0)
```

* Functions can have default values.
* You may, but don't have to, name the arguments
* If you name them, you can pass them out of order (but you shouldn't).

---

## Write lots of functions. I can't emphasize this enough.

.pull-left[
```{r functions}
f <- function(arg1, arg2, arg3 = 12, ...) {
  stuff <- arg1 * arg3
  stuff2 <- stuff + arg2
  plot(arg1, stuff2, ...)
  return(stuff2)
}
x <- rnorm(100)
```
]

.pull-right[
```{r plot-it}
y1 <- f(x, 3, 15, col = 4, pch = 19)
```
]

---

## Outputs vs. Side effects

.pull-left[
* Side effects are things a function does, outputs can be assigned to variables
* A good example is the `hist` function
* You have probably only seen the side effect which is to plot the histogram
```{r,fig.align='center', fig.height=5}
my_histogram <- hist(rnorm(1000))
```
]

.pull-right[
```{r}
my_histogram
class(my_histogram)
```

]

---

### When writing functions, program defensively, ensure behaviour

.pull-left[
```{r, error=TRUE}
incrementer <- function(x, inc_by = 1) return(x + 1)
incrementer(2)
incrementer(1:4)
incrementer("a")
```

--

```{r, error=TRUE}
incrementer <- function(x, inc_by = 1) {
  stopifnot(is.numeric(x))
  return(x + 1)
}
incrementer("a")
```

]

--

.pull-right[
```{r, error=TRUE}
incrementer <- function(x, inc_by = 1) {
  if (!is.numeric(x)) stop("`x` should be numeric")
  return(x + 1)
}
incrementer("a")
incrementer(2, -3) ## oops!
incrementer <- function(x, inc_by = 1) {
  if (!is.numeric(x)) stop("`x` should be numeric")
  return(x + inc_by)
}
incrementer(2, -3)
```
]

---

## How to keep track

.pull-left[
```{r}
library(testthat)
incrementer <- function(x, inc_by = 1) {
  if (!is.numeric(x)) stop("`x` should be numeric")
  if (!is.numeric(inc_by)) 
    stop("`inc_by` should be numeric")
  return(x + inc_by)
}
expect_error(incrementer("a"))
expect_equal(incrementer(1:3), 2:4)
expect_equal(incrementer(2, -3), -1)
expect_error(incrementer(1, "b"))
```

```{r, error=TRUE}
expect_identical(incrementer(1:3), 2:4)
```
]

--

.pull-right[
```{r}
is.integer(2:4)
is.integer(incrementer(1:3))
expect_identical(incrementer(1:3, 1L), 2:4)
```
]

--

.emphasis[
If you copy something, write a function.

Validate your arguments.

To ensure proper functionality, write tests to check if inputs result in predicted outputs.
]


---
class: middle, inverse, center

# Classes and methods

---

## Classes

.pull-left[
We saw some of these earlier:

```{r}
tib <- tibble(
  x1 = rnorm(100), 
  x2 = rnorm(100), 
  y = x1 + 2 * x2
)
mdl <- lm(y ~ ., data = tib )
class(tib)
class(mdl)
```

The class allows for the use of "methods"

```{r}
print(mdl)
```
]

--

.pull-right[
`R` "knows what to do" when you `print()` an object of class `"lm"`.

`print()` is called a "generic" function. You can create "methods" that get dispatched.

For any generic, `R` looks for a method for the class.

If available, it calls that function.

```{r}

sloop::s3_dispatch(print(incrementer))
sloop::s3_dispatch(print(tib))
sloop::s3_dispatch(print(mdl))
```
]

---


## R-Geeky But Important

There are .secondary[lots] of generic functions in `R`

Common ones are `print()`, `summary()`, and `plot()`.

Also, lots of important statistical modelling concepts:
`residuals()` `coefficients()` 

(In `python`, these work the opposite way: `obj.residuals`. The dot after the object accesses methods defined for that type of object. But the dispatch behaviour is less robust.)  

* The convention is
that the specialized function is named `method.class`, e.g., `summary.lm`.

* If no specialized function is defined, R will try to use `method.default`.

For this reason, `R` programmers try to avoid `.` in names of functions or objects.

--

### Wherefore methods?


* The advantage is that you don't have to learn a totally
new syntax to grab residuals or plot things

* You just use `residuals(mdl)` whether `mdl` comes from `lm`
could have been done two centuries ago, or a Batrachian Emphasis Machine
which won't be invented for another five years.  

* The one draw-back is the help pages for the generic methods tend
to be pretty vague

* Compare `?summary` with `?summary.lm`.  


---

# Environments 

# Debugging

# Understanding {tidyverse}